`include "../definitions.v"
`timescale 1ns / 1ps

/*
    Input:
        alu_opcode: Determine what operations the ALU will execute. The data is generated by
                            control module
        a_input:    operand 1
        b_input:    operand 2
        alu_result: the alu result of last instruction, used to solve data hazard like below
                    add $s0, $t0, $t1
                    sub $t2, $s0, $t3
        reg_write_data: the data fetched from data memory, used to solve data hazard like below
                    lw $s0, 20($t1)
                    sub $t2, $s0, $t3
        val1_sel:   select signal of alu operand 1
        val2_sel:   select signal of alu operand 2
        sw_val_sel: select signal of value to be stored into memory

    Output:
        alu_output: Result calculated by ALU
*/
module alu (
    input      [`ALU_CONTROL_WIDTH - 1:0] alu_opcode,

    input      [`FORW_SEL_WIDTH - 1:0] val2_sel,
    input      [`FORW_SEL_WIDTH - 1:0] val1_sel,

    input      [`ISA_WIDTH - 1:0] alu_result, 
    input      [`ISA_WIDTH - 1:0] reg_write_data,
    input      [`ISA_WIDTH - 1:0] a_input,
    input      [`ISA_WIDTH - 1:0] b_input,

    output reg [`ISA_WIDTH - 1:0] alu_output
    );

    reg [`ISA_WIDTH - 1:0] val1, val2;

    always @(*) begin
        case (val1_sel)
            `FORW_SEL_INPUT:   val1 = a_input;
            `FORW_SEL_ALU_RES: val1 = alu_result;
            `FORW_SEL_MEM_RES: val1 = reg_write_data;
            default:           val1 = 0;
        endcase 
        case (val2_sel)
            `FORW_SEL_INPUT:   val2 = b_input;
            `FORW_SEL_ALU_RES: val2 = alu_result;
            `FORW_SEL_MEM_RES: val2 = reg_write_data;
            default:           val2 = 0;
        endcase
    end

    integer i;
    always @(alu_opcode, val1, val2) begin
        case (alu_opcode)
            `EXE_SLL , `EXE_SLLV : alu_output = val2 << val1;
            `EXE_SRL , `EXE_SRLV : alu_output = val2 >> val1;
            `EXE_SRA , `EXE_SRAV : alu_output = $signed(val2) >>> val1;
            `EXE_ADD , `EXE_ADDI : alu_output =   $signed(val1) +   $signed(val2);
            `EXE_ADDU, `EXE_ADDIU: alu_output = $unsigned(val1) + $unsigned(val2);
            `EXE_SUB             : alu_output =   $signed(val1) -   $signed(val2);
            `EXE_SUBU            : alu_output = $unsigned(val1) - $unsigned(val2);
            `EXE_AND , `EXE_ANDI : for (i = 0; i < `ISA_WIDTH; i = i + 1) alu_output[i] = val1[i] & val2[i];
            `EXE_OR  , `EXE_ORI  : for (i = 0; i < `ISA_WIDTH; i = i + 1) alu_output[i] = val1[i] | val2[i];
            `EXE_XOR , `EXE_XORI : for (i = 0; i < `ISA_WIDTH; i = i + 1) alu_output[i] = val1[i] ^ val2[i];
            `EXE_NOR             : for (i = 0; i < `ISA_WIDTH; i = i + 1) alu_output[i] = ~(val1[i] | val2[i]);
            `EXE_SLT , `EXE_SLTI : alu_output = (  $signed(val1) <   $signed(val2)) ? 1 : 0;
            `EXE_SLTU, `EXE_SLTIU: alu_output = ($unsigned(val1) < $unsigned(val2)) ? 1 : 0;
            `EXE_LUI             : alu_output = {val2[15:0], val1[15:0]};
            default              : alu_output = 0;
        endcase
    end

endmodule
