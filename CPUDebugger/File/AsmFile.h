#ifndef ASMFILE_H
#define ASMFILE_H

#include <vector>
#include <memory>
#include <QMap>
#include <QFile>
#include <QRegularExpression>
#include <set>

#define DATA_MEM_SIZE 0x3FFF
#define TEXT_MEM_SIZE 0x3FFF

#define BYTE_LEN 8
#define WORD_LEN 32
#define ADDR_LEN 20
#define FUNC_LEN 6
#define REG_LEN 5
#define SHAMT_LEN 5
#define IMME_LEN 16
#define OFFS_LEN 26

/**
 * \author David Li
 */
class AsmFile {
public:
    /**
     * \warning
     * This way of initialization is not suggested, since the file must be opened and read for displaying the text on
     * the editor, then the file must be closed again to pass into this constructor, or vice versa, which might cause
     * confusion, use \c AsmFile() with \c loadAsmFile(QFile &newAsmFile) instead.
     * \details
     * Initializes an \c AsmFile object with a \c QFile. The file should be not opened before passing in as an
     * initialization parameter since it will be opened during initialization. The \c AsmFile object will parse the
     * \c .asm file once during initialization, the mapping between the program counter and each line (seperated by
     * \\n) will be captured in this process as well. A binary representation of the \c .asm code will also be derived
     * which can be used during UART transmission.
     * \param
     * file: the \c QFile of a user selected \c .asm file, this file must be closed as it will be opened by
     * the constructor. Note that the file will be linked to this object, when future updates occur through
     * \c updateAsmFile(), the object will automatically update the contents of the file.
     */
    explicit AsmFile(QFile &file);

    /**
     * \details
     * Initializes an \c AsmFile object. No operations will occur, that is, to get parse a \c .asm file, the separate
     * function \c loadAsmFile() can be used to manually load and automatically parse a \c .asm file and generate the
     * mapping between the program counter and each line (seperated by \\n) in the \c .asm file, together with the
     * binary representation of the machine code associated.
     */
    explicit AsmFile();

    friend class DebugController;

    ~AsmFile();

    /**
     * \details
     * Loads a \c .asm file, probably due to the user selecting a new one, and perform parsing. Resulting in a mapping
     * between the program counter and each line (seperated by \\n) in the \c .asm file, with the binary representation
     * of the machine code.
     * \param file: the \c QFile of a user selected \c .asm file, this file must be closed as it will be opened by
     * the constructor. Note that the file will be linked to this object, when future updates occur through
     * \c updateAsmFile(), the object will automatically update the contents of the file.
     * \return
     * \c QString: the full text in the \c .asm file. This string can be displayed on the code editor.
     */
    QString loadAsmFile(QFile &file);

    /**
     * \details
     * Performs an update on the contents of the last \c .asm file passed to the object, either during initialization
     * or through \c loadAsmFile(). Then parse the new text contents.
     * \param
     * asmString: the new contents of the \c .asm file, can be a new edited version by the user through the code editor.
     * \return
     * \c QByteArray: the new binary machine code generated by the updated instructions. This can be used to for the
     * flash step where the user sends machine code through UART to program the FPGA.
     */
    QByteArray updateAsmFile(QString &asmString);

    /**
     * \details
     * Retrieves the machine code generated during parsing of assembly instructions.
     * \return
     * \c QByteArray: the binary machine code generated by the parsing instructions. This can be used to for the flash
     * step where the user sends machine code through UART to program the FPGA.
     */
    QByteArray getBin();

    /**
     * \details
     * Get the corresponding program counter value of a line (seperated by \\n) in the \c .asm file. Note that until the
     * \c updateAsmFile() is called to update the contents of the original \c .asm file, this mapping will not change.
     * \param
     * asmLine: the line index of a line of code in the code editor, which should be corresponding to the line in the \c
     * .asm file. The line index starts from 0.
     * \return
     * \c unsigned \c int: the program counter value for the code line. The program counter starts from 0, and
     * increments by 4. This can be used to indicate the next breakpoint when sending a \c RESUME signal to the FPGA.
     */
    unsigned int getPC(int asmLine);

    /**
     * \details
     * Get the corresponding line (seperated by \\n) index in the \c .asm file given a program counter value. Note that
     * until the \c updateAsmFile() is called to update the contents of the original \c .asm file, this mapping will
     * not change.
     * \param
     * PC: the program counter, presumed to be from the FPGA indicating the last executed instruction. The program
     * counter starts from 0, and increments by 4.
     * \return
     * \c int: the line index of a line of code in the code editor, which should be corresponding to the line in the \c
     * .asm file. The line index starts from 0.
     */
    int getAsmLine(unsigned int PC);

    int setBreakPoints(std::set<int>& breakPoints);
    
private:
    QFile *asmFile{};

    unsigned int programCounter{};
    int          asmLine{};

    QMap<QString, int> labelMap;
    QByteArray         bin;

    QMap<int, unsigned int> asmToPCMap;
    QMap<unsigned int, int> PCToAsmMap;

    std::set<int> breakPoints = {};
    std::set<int> binBreakPoints = {};

    enum OpType {
        O_Type, R_Type, I_Type, J_Type, P_Type,
        N_Type // this is the type for non-instruction segments
    };

    void preprocess(QString &asmString);

    void parseAsm(QString asmString);

    static QByteArray asciiData(QString data, int *wordCnt);

    static bool isSingleLine(QStringList::const_iterator &wordIter);

    static bool isDoubleLine(QStringList::const_iterator &wordIter);

    static int getOpType(const QString &op);

    QString getNext(QStringList::const_iterator &instruction);

    void binAppend(uint32_t word);

    static uint32_t zeroExtend(const QString &word, int length);

    static uint32_t signExtend(const QString &word, int length);

    void O_TypeProcess(QStringList::const_iterator &wordIter);

    void R_TypeProcess(QStringList::const_iterator &wordIter);

    void I_TypeProcess(QStringList::const_iterator &wordIter);

    void J_TypeProcess(QStringList::const_iterator &wordIter);

    void P_TypeProcess(QStringList::const_iterator &wordIter);

    void pseudoCompare(QStringList::const_iterator &instruction);

    static int getRegCode(const QString &r);

    //    static QString zeroExtent(QString string, int length);
};

#endif // ASMFILE_H
